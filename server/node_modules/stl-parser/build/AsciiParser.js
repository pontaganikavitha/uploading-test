// Generated by CoffeeScript 1.10.0
(function() {
  var Ascii, AsciiParser, Binary, Polygon, Transform, Vector, assign, stream, toNumber, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  assign = Object.assign || require('object.assign');

  util = require('util');

  stream = require('stream');

  Ascii = require('./Ascii');

  Binary = require('./Binary');

  Polygon = require('./Polygon');

  Vector = require('./Vector');

  toNumber = require('./toNumber');

  Transform = stream.Transform;

  AsciiParser = (function(superClass) {
    extend(AsciiParser, superClass);

    function AsciiParser(options) {
      var base, base1, base2;
      this.options = options != null ? options : {};
      this._transform = bind(this._transform, this);
      this._flush = bind(this._flush, this);
      this.getNextWord = bind(this.getNextWord, this);
      this._parseCoordinate = bind(this._parseCoordinate, this);
      this.options.writableObjectMode = false;
      this.options.readableObjectMode = true;
      if ((base = this.options).blocking == null) {
        base.blocking = true;
      }
      if ((base1 = this.options).format == null) {
        base1.format = 'jsonl';
      }
      if ((base2 = this.options).discardExcessVertices == null) {
        base2.discardExcessVertices = true;
      }
      AsciiParser.__super__.constructor.call(this, this.options);
      this.debugBuffer = '';
      this.internalBuffer = '';
      this.last = 'root';
      this.defaultModel = {
        name: null,
        endName: null,
        isClosed: false
      };
      this.currentModel = assign({}, this.defaultModel);
      this.currentFace = {
        number: 0
      };
      this.countedFaces = 0;
      this.lineCounter = 1;
      this.characterCounter = 0;
    }

    AsciiParser.prototype._parseCoordinate = function(word, type) {
      var error, error1, value;
      value = null;
      try {
        value = toNumber(word);
      } catch (error1) {
        error = error1;
        this.emit('warning', "Unexpected '" + word + "' instead of " + type + " value in face " + this.currentFace.number + ", line " + this.lineCounter);
      }
      this.last = type;
      return value;
    };

    AsciiParser.prototype.getNextWord = function() {
      var whitespace, words;
      if (/^\s*\n\s*/gi.test(this.internalBuffer)) {
        this.lineCounter++;
      }
      whitespace = this.internalBuffer.match(/^\s+/);
      if (whitespace) {
        this.characterCounter += whitespace[0].length;
        this.internalBuffer = this.internalBuffer.substr(whitespace[0].length);
      }
      words = this.internalBuffer.match(/^\S+/);
      if ((words === null) || (words[0].length === this.internalBuffer.length)) {
        return null;
      } else {
        this.characterCounter += words[0].length;
        this.internalBuffer = this.internalBuffer.substr(words[0].length);
        if (this.options.size > 0) {
          this.emit('progress', this.characterCounter / this.options.size);
        }
        return words[0];
      }
    };

    AsciiParser.prototype._processWord = function(word) {
      if (this.last === 'vertex') {
        this.currentVertex.x = this._parseCoordinate(word, 'vertex-x');
        return;
      }
      if (this.last === 'vertex-x') {
        this.currentVertex.y = this._parseCoordinate(word, 'vertex-y');
        return;
      }
      if (this.last === 'vertex-y') {
        this.currentVertex.z = this._parseCoordinate(word, 'vertex-z');
        return;
      }
      if (word === 'vertex') {
        if (this.last === 'vertex-z' || this.last === 'loop') {
          if (this.last === 'loop') {
            this.currentFace.vertices = [];
          }
          this.currentVertex = {
            x: null,
            y: null,
            z: null
          };
          this.currentFace.vertices.push(this.currentVertex);
        } else {
          this.emit('warning', "Unexpected vertex after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        }
        this.last = 'vertex';
        return;
      }
      if (word === 'facet') {
        this.currentFace = {
          number: this.countedFaces + 1
        };
        if (this.last === 'solid') {
          if (this.currentModel.name == null) {
            this.currentModel.name = '';
            this.emit('warning', "Solid in line " + (this.lineCounter - 1) + " does not have a name");
          }
          if (this.options.format !== 'json') {
            this.push({
              name: this.currentModel.name
            });
          }
        } else if (this.last !== 'endfacet') {
          this.emit('warning', "Unexpected facet after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        }
        this.last = 'facet';
        return;
      }
      if (word === 'normal') {
        if (this.last === 'facet') {
          this.currentFace.normal = {
            x: null,
            y: null,
            z: null
          };
        } else {
          this.emit('warning', "Unexpected normal after " + this.last);
        }
        this.last = 'normal';
        return;
      }
      if (this.last === 'normal') {
        this.currentFace.normal.x = this._parseCoordinate(word, 'normal-x');
        if (this.currentFace.normal.x == null) {
          this.currentFace.normal.x = 0;
          this._processWord(word);
        }
        return;
      }
      if (this.last === 'normal-x') {
        this.currentFace.normal.y = this._parseCoordinate(word, 'normal-y');
        if (this.currentFace.normal.y == null) {
          this.currentFace.normal.y = 0;
          this._processWord(word);
        }
        return;
      }
      if (this.last === 'normal-y') {
        this.currentFace.normal.z = this._parseCoordinate(word, 'normal-z');
        if (this.currentFace.normal.z == null) {
          this.currentFace.normal.z = 0;
          this._processWord(word);
        }
        return;
      }
      if (word === 'outer') {
        if (this.last === 'normal-z') {
          this.last = 'outer';
          return;
        } else {
          this.emit('warning', "Unexpected outer after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        }
      }
      if (word === 'loop') {
        if (this.last !== 'outer') {
          this.emit('warning', "Unexpected loop after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        }
        this.last = 'loop';
        return;
      }
      if (word === 'endloop') {
        if (this.last !== 'vertex-z') {
          this.emit('warning', "Unexpected endloop after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        } else if (this.currentFace.vertices.length !== 3) {
          this.emit('warning', "Face " + this.currentFace.number + " has " + this.currentFace.vertices.length + " instead of 3 vertices");
          if (this.currentFace.vertices.length > 3) {
            if (this.options.discardExcessVertices) {
              this.currentFace.vertices.splice(3);
            }
          } else {
            this.currentFace = null;
          }
        }
        this.last = 'endloop';
        return;
      }
      if (word === 'endfacet') {
        if (this.last === 'endloop') {
          if (this.currentFace && this.currentFace.vertices) {
            this.countedFaces++;
            if (this.options.format === 'json') {
              this.currentModel.faces.push(this.currentFace);
            } else {
              this.push(this.currentFace);
            }
          }
        } else {
          this.emit('warning', "Unexpected endfacet after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        }
        this.last = 'endfacet';
        return;
      }
      if (word === 'endsolid') {
        if (this.options.format === 'json' || this.last === 'solid') {
          this.push({
            name: this.currentModel.name,
            type: 'ascii',
            faces: this.currentModel.faces
          });
        }
        if (this.last === 'endfacet' || this.last === 'solid') {
          this.currentModel.isClosed = true;
        } else {
          this.emit('warning', "Unexpected endsolid after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        }
        this.last = 'endsolid';
        return;
      }
      if (word === 'solid') {
        if (this.last === 'root' || this.last === 'endsolid') {
          this.currentModel = assign({}, this.defaultModel);
          this.currentFace = {
            number: 0
          };
          if (this.options.format === 'json') {
            this.currentModel.faces = [];
          }
        } else {
          this.emit('warning', "Unexpected solid after " + this.last + " in face " + this.currentFace.number + " in line " + this.lineCounter);
        }
        this.last = 'solid';
        return;
      }
      if (this.last === 'solid') {
        if (typeof this.currentModel.name === 'string') {
          this.currentModel.name += ' ' + word;
        } else {
          this.currentModel.name = word;
        }
        return;
      }
      if (this.last === 'endsolid') {
        if (typeof this.currentModel.endName === 'string') {
          return this.currentModel.endName += ' ' + word;
        } else {
          return this.currentModel.endName = word;
        }
      }
    };

    AsciiParser.prototype._flush = function(done) {
      var ref;
      if (!this.currentModel.isClosed && this.countedFaces === 0 && this.currentModel.name === null && this.currentModel.endName === null) {
        this.emit('warning', 'Provided ascii STL should probably be parsed as a binary STL');
      }
      if (Boolean(this.currentModel.endName) !== Boolean(this.currentModel.name)) {
        this.emit('warning', "Solid name (\"" + (this.currentModel.name.substr(0, 50)) + "\") and endsolid name (\"" + this.currentModel.endName + "\") do not match");
      }
      if (this.countedFaces === 0) {
        if (((ref = this.currentModel.name) != null ? ref.length : void 0) > 50) {
          this.currentModel.name = this.currentModel.name.substr(0, 50) + '…';
        }
        this.emit('warning', 'Solid ' + (this.currentModel.name ? "'" + this.currentModel.name + "'" : '<no name>') + ' does not contain any faces');
      }
      if (this.currentModel.name === null) {
        return done(new Error('Provided ascii STL contains an invalid solid'));
      }
      if (!this.currentModel.isClosed && this.internalBuffer !== 'endsolid') {
        return done(new Error('Provided ascii STL is not closed with endsolid keyword'));
      }
      this.emit('progress', 1);
      return done();
    };

    AsciiParser.prototype._callAtEnd = function(done) {
      if (this.options.blocking) {
        return done();
      } else {
        return setTimeout(done, 4);
      }
    };

    AsciiParser.prototype._transform = function(chunk, encoding, done) {
      var word;
      this.internalBuffer += chunk.toString();
      while (word = this.getNextWord()) {
        this._processWord(word);
      }
      return this._callAtEnd(done);
    };

    return AsciiParser;

  })(Transform);

  module.exports = AsciiParser;

}).call(this);
