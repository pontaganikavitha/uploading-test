// Generated by CoffeeScript 1.10.0
(function() {
  var AsciiParser, BinaryParser, StlParser, clone, stream,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  require('string.prototype.startswith');

  stream = require('stream');

  clone = require('clone');

  AsciiParser = require('./AsciiParser');

  BinaryParser = require('./BinaryParser');

  StlParser = (function(superClass) {
    extend(StlParser, superClass);

    function StlParser(options) {
      var base, base1;
      this.options = options != null ? options : {};
      this.firstCall = true;
      if ((base = this.options).writableObjectMode == null) {
        base.writableObjectMode = false;
      }
      if ((base1 = this.options).readableObjectMode == null) {
        base1.readableObjectMode = true;
      }
      StlParser.__super__.constructor.call(this, this.options);
    }

    StlParser.prototype._flush = function(done) {
      if (this.parser) {
        this.parser.end();
      } else {
        this.emit('error', new Error('Provided STL-string must not be empty'));
      }
      return done();
    };

    StlParser.prototype._transform = function(chunk, encoding, done) {
      if (this.firstCall) {
        this.firstCall = false;
        if ((this.options.type !== 'binary' && chunk.toString().startsWith('solid')) || this.options.type === 'ascii') {
          this.parser = new AsciiParser(clone(this.options));
          if (this.options.format !== 'json') {
            this.push(this.options.readableObjectMode ? {
              type: 'ascii'
            } : JSON.stringify({
              type: 'ascii'
            }) + '\n');
          }
        } else {
          this.parser = new BinaryParser(clone(this.options));
          if (this.options.format !== 'json') {
            this.push(this.options.readableObjectMode ? {
              type: 'binary'
            } : JSON.stringify({
              type: 'binary'
            }) + '\n');
          }
        }
        this.parser.on('data', (function(_this) {
          return function(data) {
            if (_this.options.readableObjectMode) {
              return _this.push(data);
            } else {
              return _this.push(JSON.stringify(data) + '\n');
            }
          };
        })(this));
        this.parser.on('end', (function(_this) {
          return function() {
            return _this.push(null);
          };
        })(this));
        this.parser.on('error', (function(_this) {
          return function(error) {
            return _this.emit('error', error);
          };
        })(this));
        this.parser.on('warning', (function(_this) {
          return function(warning) {
            return _this.emit('warning', warning);
          };
        })(this));
        this.parser.on('progress', (function(_this) {
          return function(progress) {
            return _this.emit('progress', progress);
          };
        })(this));
      }
      return this.parser.write(chunk, function() {
        return done();
      });
    };

    return StlParser;

  })(stream.Transform);

  module.exports = StlParser;

}).call(this);
