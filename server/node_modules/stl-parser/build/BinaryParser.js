// Generated by CoffeeScript 1.10.0
(function() {
  var Ascii, Binary, BinaryParser, Polygon, Vector, bufferTrim, stream, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  util = require('util');

  stream = require('stream');

  bufferTrim = require('buffertrim');

  Ascii = require('./Ascii');

  Binary = require('./Binary');

  Polygon = require('./Polygon');

  Vector = require('./Vector');

  BinaryParser = (function(superClass) {
    extend(BinaryParser, superClass);

    function BinaryParser(options) {
      var base, base1;
      this.options = options != null ? options : {};
      this._flush = bind(this._flush, this);
      this.options.writableObjectMode = false;
      this.options.readableObjectMode = true;
      if ((base = this.options).blocking == null) {
        base.blocking = true;
      }
      if ((base1 = this.options).format == null) {
        base1.format = 'jsonl';
      }
      BinaryParser.__super__.constructor.call(this, this.options);
      this.internalBuffer = new Buffer(0);
      this.header = '';
      this.faceCounter = 0;
      this.countedFaces = 0;
      this.cursor = 80;
      this.currentModel = {
        name: null,
        faceCount: null
      };
      this.currentFace = {};
      this.headerByteCount = 80;
      this.vertexByteCount = 12;
      this.attributeByteCount = 2;
      this.facesCounterByteCount = 4;
      this.faceByteCount = 50;
      this.facesOffset = this.headerByteCount + this.facesCounterByteCount;
      this.coordinateByteCount = 4;
    }

    BinaryParser.prototype._flush = function(done) {
      if (this.countedFaces === 0) {
        this.emit('error', new Error('No faces were specified in the binary STL'));
      } else if (this.faceCounter !== this.countedFaces) {
        this.emit('warning', "Number of specified faces (" + this.faceCounter + ") and counted number of faces (" + this.countedFaces + ") do not match");
      }
      if (this.options.format === 'json') {
        this.currentModel.type = 'binary';
        this.push(this.currentModel);
        return done(null, this.internalBuffer);
      } else {
        return done(null, this.internalBuffer);
      }
    };

    BinaryParser.prototype._transform = function(chunk, encoding, done) {
      var i, j;
      this.internalBuffer = Buffer.concat([this.internalBuffer, chunk]);
      while (this.cursor <= this.internalBuffer.length) {
        if (this.cursor === this.headerByteCount) {
          this.header = bufferTrim.trimEnd(this.internalBuffer.slice(0, this.headerByteCount)).toString();
          this.currentModel.name = this.header;
          if (this.options.format === 'json') {
            this.currentModel.faces = [];
          }
          this.cursor += this.facesCounterByteCount;
          continue;
        }
        if (this.cursor === this.facesOffset) {
          this.faceCounter = this.internalBuffer.readUInt32LE(this.headerByteCount);
          this.currentModel.faceCount = this.faceCounter;
          if (this.options.format !== 'json') {
            this.push(this.currentModel);
          }
          this.cursor += this.faceByteCount;
          continue;
        }
        if (this.cursor = this.facesOffset + (this.countedFaces + 1) * this.faceByteCount) {
          this.cursor -= this.faceByteCount;
          this.currentFace = {
            number: this.countedFaces + 1,
            normal: {
              x: this.internalBuffer.readFloatLE(this.cursor),
              y: this.internalBuffer.readFloatLE(this.cursor += this.coordinateByteCount),
              z: this.internalBuffer.readFloatLE(this.cursor += this.coordinateByteCount)
            },
            vertices: []
          };
          for (i = j = 0; j <= 2; i = ++j) {
            this.currentFace.vertices.push({
              x: this.internalBuffer.readFloatLE(this.cursor += this.coordinateByteCount),
              y: this.internalBuffer.readFloatLE(this.cursor += this.coordinateByteCount),
              z: this.internalBuffer.readFloatLE(this.cursor += this.coordinateByteCount)
            });
          }
          this.currentFace.attribute = this.internalBuffer.readUInt16LE(this.cursor += this.coordinateByteCount);
          this.cursor += this.attributeByteCount;
          if (this.options.format === 'json') {
            this.currentModel.faces.push(this.currentFace);
          } else {
            this.push(this.currentFace);
          }
          this.cursor += this.faceByteCount;
          this.countedFaces++;
        }
      }
      if (this.options.blocking) {
        return done();
      } else {
        return setTimeout(done, 4);
      }
    };

    return BinaryParser;

  })(stream.Transform);

  module.exports = BinaryParser;

}).call(this);
